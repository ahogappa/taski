module Taski
  VERSION: String

  self.@global_registry: Execution::Registry?
  self.@progress_display: Execution::TreeProgressDisplay?
  self.@context: Context?

  # Type alias for Task class (singleton type with class methods)
  # This represents a Class that inherits from Taski::Task
  type task_class = singleton(Task)

  # Module-level methods
  def self.global_registry: () -> Execution::Registry
  def self.reset_global_registry!: () -> void
  def self.progress_display: () -> Execution::TreeProgressDisplay?
  def self.progress_disabled?: () -> bool
  def self.reset_progress_display!: () -> void
  def self.context: () -> Hash[Symbol, untyped]
  def self.start_context: (options: Hash[Symbol, untyped], root_task: Class) -> void
  def self.reset_context!: () -> void

  # Custom exceptions
  class TaskAbortException < StandardError
  end

  class CircularDependencyError < StandardError
    @cyclic_tasks: Array[Array[Class]]

    attr_reader cyclic_tasks: Array[Array[Class]]

    def initialize: (Array[Array[Class]] cyclic_tasks) -> void
  end

  # Context class for execution context management
  class Context
    @options: Hash[Symbol | String, untyped]
    @root_task: Class
    @started_at: Time
    @working_directory: String

    attr_reader started_at: Time
    attr_reader working_directory: String
    attr_reader root_task: Class

    def initialize: (options: Hash[Symbol | String, untyped], root_task: Class) -> void
    def []: (Symbol | String key) -> untyped
    def fetch: (Symbol | String key, ?untyped default) ?{ () -> untyped } -> untyped
    def key?: (Symbol | String key) -> bool
  end

  # Main Task class
  class Task
    self.@exported_methods: Array[Symbol]
    self.@dependencies_cache: Set[task_class]?
    self.@circular_dependency_checked: bool

    # Class methods
    def self.exports: (*Symbol names) -> void
    def self.exported_methods: () -> Array[Symbol]
    def self.new: () -> Execution::TaskWrapper
    def self.cached_dependencies: () -> Set[task_class]
    def self.clear_dependency_cache: () -> void
    def self.run: (?context: Hash[Symbol, untyped]) -> untyped
    def self.clean: (?context: Hash[Symbol, untyped]) -> void
    def self.registry: () -> Execution::Registry
    def self.reset!: () -> void
    def self.tree: () -> String

    # Instance methods
    def run: () -> void
    def clean: () -> void
    def reset!: () -> void

    private

    # Private class methods
    def self.cached_wrapper: () -> Execution::TaskWrapper
    def self.define_instance_reader: (Symbol method_name) -> void
    def self.define_class_accessor: (Symbol method_name) -> void
    def self.validate_no_circular_dependencies!: () -> void
  end

  # Section class for abstraction layers (inherits from Task)
  class Section < Task
    def self.interfaces: (*Symbol interface_methods) -> void

    def run: () -> void
    def impl: () -> task_class

    private

    def apply_interface_to_implementation: (task_class implementation_class) -> void
  end

  # Execution module
  module Execution
    # TaskTiming struct (Data.define)
    class TaskTiming
      attr_reader start_time: Time
      attr_reader end_time: Time?

      # Data.define provides both positional and keyword argument constructors
      def initialize: (Time start_time, Time? end_time) -> void
                    | (start_time: Time, end_time: Time?) -> void

      def self.new: (Time start_time, Time? end_time) -> TaskTiming
                  | (start_time: Time, end_time: Time?) -> TaskTiming

      def self.start_now: () -> TaskTiming
      def duration_ms: () -> (Integer | Float)?
      def with_end_now: () -> TaskTiming
      def with: (?start_time: Time, ?end_time: Time?) -> TaskTiming
    end

    # Registry class for task instance management
    class Registry
      @tasks: Hash[Class, TaskWrapper]
      @threads: Array[Thread]
      @monitor: Monitor
      @abort_requested: bool

      def initialize: () -> void
      def get_or_create: (Class task_class) { () -> TaskWrapper } -> TaskWrapper
      def get_task: (Class task_class) -> TaskWrapper?
      def register: (Class task_class, TaskWrapper wrapper) -> void
      def register_thread: (Thread thread) -> void
      def wait_all: () -> void
      def reset!: () -> void
      def request_abort!: () -> void
      def abort_requested?: () -> bool
      def run: (Class task_class, Array[Symbol] exported_methods) -> untyped
    end

    # Executor class for parallel task execution (Producer-Consumer pattern)
    class Executor
      STATE_PENDING: Symbol
      STATE_ENQUEUED: Symbol
      STATE_COMPLETED: Symbol

      @registry: Registry
      @worker_count: Integer
      @execution_queue: Thread::Queue
      @completion_queue: Thread::Queue
      @workers: Array[Thread]
      @dependencies: Hash[Class, Set[Class]]
      @task_states: Hash[Class, Symbol]
      @completed_tasks: Set[Class]

      def self.execute: (Class root_task_class, registry: Registry) -> void
      def initialize: (registry: Registry, ?worker_count: Integer?) -> void
      def execute: (Class root_task_class) -> void

      private

      def default_worker_count: () -> Integer
      def build_dependency_graph: (Class root_task_class) -> void
      def enqueue_ready_tasks: () -> void
      def ready_to_execute?: (Class task_class) -> bool
      def enqueue_task: (Class task_class) -> void
      def get_or_create_wrapper: (Class task_class) -> TaskWrapper
      def start_workers: () -> void
      def worker_loop: () -> void
      def execute_task: (Class task_class, TaskWrapper wrapper) -> void
      def run_main_loop: (Class root_task_class) -> void
      def no_running_tasks?: () -> bool
      def handle_completion: (Hash[Symbol, untyped] event) -> void
      def shutdown_workers: () -> void
      def debug_log: (String message) -> void
    end

    # TaskWrapper class for task execution
    class TaskWrapper
      attr_reader task: Task
      attr_reader result: untyped
      attr_reader error: StandardError?
      attr_reader timing: TaskTiming?

      @task: Task
      @registry: Registry
      @result: untyped
      @clean_result: untyped
      @error: StandardError?
      @monitor: Monitor
      @condition: MonitorMixin::ConditionVariable
      @clean_condition: MonitorMixin::ConditionVariable
      @state: Symbol
      @clean_state: Symbol
      @timing: TaskTiming?

      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol

      def initialize: (Task task, registry: Registry) -> void
      def state: () -> Symbol
      def pending?: () -> bool
      def completed?: () -> bool
      def run: () -> untyped
      def clean: () -> untyped
      def get_exported_value: (Symbol method_name) -> untyped
      def mark_running: () -> bool
      def mark_completed: (untyped result) -> void
      def mark_failed: (StandardError error) -> void
      def mark_clean_completed: (untyped result) -> void
      def wait_for_completion: () -> void
      def wait_for_clean_completion: () -> void
      def method_missing: (Symbol name, *untyped args) ?{ (*untyped) -> untyped } -> untyped
      def respond_to_missing?: (Symbol name, ?bool include_private) -> bool

      private

      def trigger_execution_and_wait: () -> void
      def trigger_clean_and_wait: () -> void
      def execute_clean: () -> void
      def wait_for_clean_dependencies: () -> void
      def check_abort!: () -> void
      def update_progress: (Symbol state, ?duration: Numeric?, ?error: Exception?) -> void
      def debug_log: (String message) -> void
    end

    # TreeProgressDisplay class for tree-based progress visualization
    class TreeProgressDisplay
      SPINNER_FRAMES: Array[String]
      COLORS: Hash[Symbol, String]
      ICONS: Hash[Symbol, String]

      @output: IO
      @tasks: Hash[Class, TaskProgress]
      @monitor: Monitor
      @spinner_index: Integer
      @renderer_thread: Thread?
      @running: bool
      @nest_level: Integer
      @root_task_class: Class?
      @tree_structure: Hash[Symbol, untyped]?
      @section_impl_map: Hash[Class, Class]
      @last_line_count: Integer

      # Shared class methods
      def self.section_class?: (Class klass) -> bool
      def self.nested_class?: (Class child_class, Class parent_class) -> bool
      def self.render_static_tree: (Class root_task_class) -> String

      # Static tree renderer (internal class)
      class StaticTreeRenderer
        @task_index_map: Hash[Class, Integer]

        def render: (Class root_task_class) -> String

        private

        def build_tree: (Class task_class, String prefix, bool is_impl, Set[Class] ancestors) -> String
        def render_dependency_branch: (Class dep, String prefix, bool is_last, bool is_impl, Set[Class] ancestors) -> String
        def get_task_number: (Class task_class) -> String
        def colored_type_label: (Class klass) -> String
      end

      class TaskProgress
        attr_accessor state: Symbol
        attr_accessor start_time: Time?
        attr_accessor end_time: Time?
        attr_accessor error: Exception?
        attr_accessor duration: Numeric?
        attr_accessor is_impl_candidate: bool

        def initialize: () -> void
      end

      def initialize: (?output: IO) -> void
      def set_root_task: (Class root_task_class) -> void
      def register_section_impl: (Class section_class, Class impl_class) -> void
      def register_task: (Class task_class) -> void
      def task_registered?: (Class task_class) -> bool
      def update_task: (Class task_class, state: Symbol, ?duration: Numeric?, ?error: Exception?) -> void
      def task_state: (Class task_class) -> Symbol?
      def start: () -> void
      def stop: () -> void

      private

      def build_tree_structure: () -> void
      def build_tree_node: (Class task_class, Set[Class] ancestors) -> Hash[Symbol, untyped]?
      def register_tasks_from_tree: (Hash[Symbol, untyped] node) -> void
      def render_live: () -> void
      def render_final: () -> void
      def build_tree_display: () -> Array[String]
      def build_root_tree_lines: (Hash[Symbol, untyped] node, String prefix, Array[String] lines) -> void
      def render_children: (Hash[Symbol, untyped] node, String prefix, Array[String] lines, Class parent_task_class, bool ancestor_selected) -> void
      def format_tree_line: (Class task_class, TaskProgress? progress, bool is_impl, bool is_selected) -> String
      def format_unknown_task: (Class task_class, ?bool is_selected) -> String
      def task_status_icon: (Symbol state, bool is_selected) -> String
      def spinner_char: () -> String
      def type_label_for: (Class task_class, ?bool is_selected) -> String
      def task_details: (TaskProgress progress) -> String
      def section_class?: (Class klass) -> bool
      def nested_class?: (Class child_class, Class parent_class) -> bool
    end
  end

  # StaticAnalysis module
  module StaticAnalysis
    # Analyzer class for dependency analysis
    class Analyzer
      def self.analyze: (Class task_class) -> Set[task_class]

      private

      def self.target_method_for: (Class task_class) -> Symbol
      def self.extract_method_location: (Class task_class, Symbol method_name) -> [String, Integer]?
    end

    # Visitor class for AST traversal
    class Visitor < Prism::Visitor
      @target_task_class: Class
      @target_method: Symbol
      @dependencies: Set[task_class]
      @in_target_method: bool
      @current_namespace_path: Array[String?]

      attr_reader dependencies: Set[task_class]

      def initialize: (Class task_class, Symbol target_method) -> void
      def visit_class_node: (Prism::ClassNode node) -> untyped
      def visit_module_node: (Prism::ModuleNode node) -> untyped
      def visit_def_node: (Prism::DefNode node) -> untyped
      def visit_call_node: (Prism::CallNode node) -> untyped

      private

      def within_namespace: (String? name) { () -> void } -> void
      def in_target_class?: () -> bool
      def in_impl_method?: () -> bool
      def extract_constant_name: (untyped node) -> String?
      def detect_task_dependency: (Prism::CallNode node) -> void
      def detect_impl_candidate: (untyped node) -> void
      def extract_receiver_constant: (untyped receiver) -> String?
      def resolve_and_add_dependency: (String constant_name) -> void
      def resolve_constant: (String name) -> task_class?
      def resolve_with_namespace_prefix: (String name) -> task_class?
      def valid_dependency?: (task_class klass) -> bool
      def is_parallel_task?: (task_class klass) -> boolish
      def is_parallel_section?: (task_class klass) -> boolish
    end

    # DependencyGraph class for topological sorting and cycle detection
    class DependencyGraph
      include TSort[Class]

      @graph: Hash[Class, Set[Class]]

      def initialize: () -> void
      def build_from: (Class root_task_class) -> self
      def sorted: () -> Array[Class]
      def cyclic?: () -> bool
      def strongly_connected_components: () -> Array[Array[Class]]
      def cyclic_components: () -> Array[Array[Class]]
      def all_tasks: () -> Array[Class]
      def dependencies_for: (Class task) -> Set[Class]

      # TSort interface methods (required by TSort module)
      def tsort_each_node: () { (Class) -> void } -> void
      def tsort_each_child: (Class node) { (Class) -> void } -> void

      private

      def collect_dependencies: (Class task_class) -> void
    end
  end
end
