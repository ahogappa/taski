module Taski
  VERSION: String

  self.@global_registry: Execution::Registry?
  self.@progress_display: Progress::Layout::Base?
  self.@args: Args?
  self.@args_monitor: Monitor

  # Type alias for Task class (singleton type with class methods)
  # This represents a Class that inherits from Taski::Task
  type task_class = singleton(Task)

  # Module-level methods
  def self.global_registry: () -> Execution::Registry
  def self.reset_global_registry!: () -> void
  def self.progress_display: () -> Progress::Layout::Base?
  def self.progress_disabled?: () -> bool
  def self.reset_progress_display!: () -> void
  def self.args: () -> Args?
  def self.start_args: (options: Hash[Symbol, untyped], root_task: Class) -> void
  def self.reset_args!: () -> void
  def self.args_worker_count: () -> Integer?

  # Custom exceptions
  class TaskAbortException < StandardError
  end

  class CircularDependencyError < StandardError
    @cyclic_tasks: Array[Array[Class]]

    attr_reader cyclic_tasks: Array[Array[Class]]

    def initialize: (Array[Array[Class]] cyclic_tasks) -> void
  end

  # Represents a single task failure with its context
  class TaskFailure
    @task_class: Class
    @error: Exception

    attr_reader task_class: Class
    attr_reader error: Exception

    def initialize: (task_class: Class, error: Exception) -> void
  end

  # Mixin for exception classes to enable transparent rescue matching with AggregateError
  module AggregateAware
    def ===: (untyped other) -> bool
  end

  # Base class for task-specific error wrappers
  class TaskError < StandardError
    extend AggregateAware

    @cause: Exception
    @task_class: Class

    attr_reader cause: Exception
    attr_reader task_class: Class

    def initialize: (Exception cause, task_class: Class) -> void
  end

  # Raised when multiple tasks fail during parallel execution
  class AggregateError < StandardError
    @errors: Array[TaskFailure]

    attr_reader errors: Array[TaskFailure]

    def initialize: (Array[TaskFailure] errors) -> void
    def cause: () -> Exception?
    def includes?: (Class exception_class) -> bool

    private

    def build_message: () -> String
  end

  # Args class for execution arguments management
  class Args
    @options: Hash[Symbol | String, untyped]
    @root_task: Class
    @started_at: Time
    @working_directory: String

    attr_reader started_at: Time
    attr_reader working_directory: String
    attr_reader root_task: Class

    def initialize: (options: Hash[Symbol | String, untyped], root_task: Class) -> void
    def []: (Symbol | String key) -> untyped
    def fetch: (Symbol | String key, ?untyped default) ?{ () -> untyped } -> untyped
    def key?: (Symbol | String key) -> bool
  end

  # Main Task class
  class Task
    self.@exported_methods: Array[Symbol]
    self.@dependencies_cache: Set[task_class]?
    self.@circular_dependency_checked: bool

    # Class methods
    def self.inherited: (Class subclass) -> void
    def self.exports: (*Symbol names) -> void
    def self.exported_methods: () -> Array[Symbol]
    def self.new: () -> Execution::TaskWrapper
    def self.cached_dependencies: () -> Set[task_class]
    def self.clear_dependency_cache: () -> void
    def self.run: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> untyped
    def self.clean: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> void
    def self.run_and_clean: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> untyped
    def self.registry: () -> Execution::Registry
    def self.reset!: () -> void
    def self.tree: () -> String

    # Instance methods
    def run: () -> void
    def clean: () -> void
    def system: (*untyped args, **untyped opts) -> bool?
    def reset!: () -> void

    private

    # Private class methods
    def self.cached_wrapper: () -> Execution::TaskWrapper
    def self.define_instance_reader: (Symbol method_name) -> void
    def self.define_class_accessor: (Symbol method_name) -> void
    def self.validate_no_circular_dependencies!: () -> void
    def self.validate_workers!: (untyped workers) -> void
  end

  # Execution module
  module Execution
    # TaskTiming struct (Data.define)
    class TaskTiming
      attr_reader start_time: Time
      attr_reader end_time: Time?

      # Data.define provides both positional and keyword argument constructors
      def initialize: (Time start_time, Time? end_time) -> void
                    | (start_time: Time, end_time: Time?) -> void

      def self.new: (Time start_time, Time? end_time) -> TaskTiming
                  | (start_time: Time, end_time: Time?) -> TaskTiming

      def self.start_now: () -> TaskTiming
      def duration_ms: () -> (Integer | Float)?
      def with_end_now: () -> TaskTiming
      def with: (?start_time: Time, ?end_time: Time?) -> TaskTiming
    end

    # Registry class for task instance management
    class Registry
      @tasks: Hash[Class, TaskWrapper]
      @threads: Array[Thread]
      @monitor: Monitor
      @abort_requested: bool

      def initialize: () -> void
      def get_or_create: (Class task_class) { () -> TaskWrapper } -> TaskWrapper
      def get_task: (Class task_class) -> TaskWrapper?
      def register: (Class task_class, TaskWrapper wrapper) -> void
      def register_thread: (Thread thread) -> void
      def wait_all: () -> void
      def reset!: () -> void
      def request_abort!: () -> void
      def abort_requested?: () -> bool
      def run: (Class task_class, Array[Symbol] exported_methods) -> untyped
      def failed_wrappers: () -> Array[TaskWrapper]
      def failed_clean_wrappers: () -> Array[TaskWrapper]
    end

    # ExecutionContext manages execution state and notifies observers about execution events
    class ExecutionContext
      THREAD_LOCAL_KEY: Symbol

      @monitor: Monitor
      @observers: Array[untyped]
      @execution_trigger: (^(Class, Registry) -> void)?
      @clean_trigger: (^(Class, Registry) -> void)?
      @output_capture: TaskOutputRouter?
      @original_stdout: IO?

      def self.current: () -> ExecutionContext?
      def self.current=: (ExecutionContext? context) -> void

      def initialize: () -> void
      def output_capture_active?: () -> bool
      def original_stdout: () -> IO?
      def setup_output_capture: (IO output_io) -> void
      def teardown_output_capture: () -> void
      def output_capture: () -> TaskOutputRouter?
      def execution_trigger=: ((^(Class, Registry) -> void)? trigger) -> void
      def clean_trigger=: ((^(Class, Registry) -> void)? trigger) -> void
      def trigger_execution: (Class task_class, registry: Registry) -> void
      def trigger_clean: (Class task_class, registry: Registry) -> untyped
      def add_observer: (untyped observer) -> void
      def remove_observer: (untyped observer) -> void
      def observers: () -> Array[untyped]
      def notify_task_registered: (Class task_class) -> void
      def notify_task_started: (Class task_class) -> void
      def notify_task_completed: (Class task_class, ?duration: Float?, ?error: Exception?) -> void
      def notify_task_skipped: (Class task_class) -> void
      def notify_set_root_task: (Class task_class) -> void
      def notify_set_output_capture: (TaskOutputRouter output_capture) -> void
      def notify_start: () -> void
      def notify_stop: () -> void
      def notify_clean_started: (Class task_class) -> void
      def notify_clean_completed: (Class task_class, ?duration: Float?, ?error: Exception?) -> void
      def notify_group_started: (Class task_class, String group_name) -> void
      def notify_group_completed: (Class task_class, String group_name, ?duration: Float?, ?error: Exception?) -> void

      private

      def dispatch: (Symbol method_name, *untyped args, **untyped kwargs) -> void
    end

    # TaskOutputRouter for routing task output
    class TaskOutputRouter
      def initialize: (IO original_io, ?ExecutionContext? execution_context) -> void
      def current_write_io: () -> IO?
      def start_capture: (Class task_class) -> void
      def stop_capture: () -> void
    end

    # Scheduler manages task dependency state and determines execution order
    class Scheduler
      STATE_PENDING: Symbol
      STATE_ENQUEUED: Symbol
      STATE_COMPLETED: Symbol
      CLEAN_STATE_PENDING: Symbol
      CLEAN_STATE_ENQUEUED: Symbol
      CLEAN_STATE_COMPLETED: Symbol

      @dependencies: Hash[Class, Array[Class]]
      @task_states: Hash[Class, Symbol]
      @completed_tasks: Set[Class]
      @reverse_dependencies: Hash[Class, Set[Class]]
      @clean_task_states: Hash[Class, Symbol]
      @clean_completed_tasks: Set[Class]

      def initialize: () -> void
      def build_dependency_graph: (Class root_task_class) -> void
      def next_ready_tasks: () -> Array[Class]
      def mark_enqueued: (Class task_class) -> void
      def mark_completed: (Class task_class) -> void
      def completed?: (Class task_class) -> bool
      def running_tasks?: () -> bool
      def task_count: () -> Integer
      def skipped_task_classes: () -> Array[Class]
      def build_reverse_dependency_graph: (Class root_task_class) -> void
      def next_ready_clean_tasks: () -> Array[Class]
      def mark_clean_enqueued: (Class task_class) -> void
      def mark_clean_completed: (Class task_class) -> void
      def clean_completed?: (Class task_class) -> bool
      def running_clean_tasks?: () -> bool

      private

      def ready_to_execute?: (Class task_class) -> bool
      def ready_to_clean?: (Class task_class) -> bool
    end

    # WorkerPool manages N threads, each with its own command Queue
    # Tasks are executed within Fibers on worker threads
    class WorkerPool
      attr_reader worker_count: Integer

      @shared_state: SharedState
      @registry: Registry
      @execution_context: ExecutionContext
      @worker_count: Integer
      @completion_queue: Thread::Queue
      @threads: Array[Thread]
      @thread_queues: Array[Thread::Queue]
      @next_thread_index: Integer
      @fiber_contexts_mutex: Mutex
      @fiber_contexts: Hash[Integer, Array[untyped]]

      def initialize: (shared_state: SharedState, registry: Registry, execution_context: ExecutionContext, completion_queue: Thread::Queue, ?worker_count: Integer?) -> void
      def start: () -> void
      def enqueue: (Class task_class, TaskWrapper wrapper) -> void
      def shutdown: () -> void

      private

      def default_worker_count: () -> Integer
      def worker_loop: (Thread::Queue queue) -> void
      def drive_fiber: (Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def run_fiber_loop: (Fiber fiber, Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def handle_dependency: (Class dep_class, Symbol method, Fiber fiber, Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def continue_fiber: (Fiber fiber, untyped value, Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def continue_fiber_with_error: (Fiber fiber, Exception error, Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def resume_fiber: (Fiber fiber, untyped value, Thread::Queue queue) -> void
      def resume_fiber_with_error: (Fiber fiber, Exception error, Thread::Queue queue) -> void
      def start_dependency: (Class dep_class, Thread::Queue queue) -> void
      def complete_task: (Class task_class, TaskWrapper wrapper, untyped result) -> void
      def fail_task: (Class task_class, TaskWrapper wrapper, Exception error) -> void
      def setup_fiber_context: () -> void
      def teardown_fiber_context: () -> void
      def start_output_capture: (Class task_class) -> void
      def stop_output_capture: () -> void
      def store_fiber_context: (Fiber fiber, Class task_class, TaskWrapper wrapper) -> void
      def get_fiber_context: (Fiber fiber) -> Array[untyped]?
      def get_or_create_wrapper: (Class task_class) -> TaskWrapper
      def debug_log: (String message) -> void
    end

    # Executor orchestrates both run and clean phases of task execution
    # Run phase uses Fiber-based WorkerPool; clean phase uses inline thread pool
    class Executor
      @registry: Registry
      @completion_queue: Thread::Queue
      @execution_context: ExecutionContext
      @scheduler: Scheduler
      @effective_worker_count: Integer?
      @shared_state: SharedState
      @enqueued_tasks: Set[Class]
      @worker_pool: WorkerPool?
      @clean_queue: Thread::Queue?
      @clean_threads: Array[Thread]?
      @saved_output_capture: TaskOutputRouter?

      def self.execute: (Class root_task_class, registry: Registry, ?execution_context: ExecutionContext?) -> void
      def self.execute_clean: (Class root_task_class, registry: Registry, ?execution_context: ExecutionContext?) -> void
      def initialize: (registry: Registry, ?worker_count: Integer?, ?execution_context: ExecutionContext?) -> void
      def execute: (Class root_task_class) -> void
      def execute_clean: (Class root_task_class) -> void

      private

      def pre_start_leaf_tasks: () -> void
      def enqueue_root_if_needed: (Class root_task_class) -> void
      def run_main_loop: (Class root_task_class) -> void
      def handle_completion: (Hash[Symbol, untyped] event) -> void
      def notify_skipped_tasks: () -> void
      def start_clean_workers: () -> void
      def shutdown_clean_workers: () -> void
      def enqueue_ready_clean_tasks: () -> void
      def enqueue_clean_task: (Class task_class) -> void
      def execute_clean_task: (Class task_class, TaskWrapper wrapper) -> void
      def run_clean_main_loop: (Class root_task_class) -> void
      def handle_clean_completion: (Hash[Symbol, untyped] event) -> void
      def all_tasks_cleaned?: () -> bool
      def get_or_create_wrapper: (Class task_class) -> TaskWrapper
      def with_task_context: (Class task_class) { () -> void } -> void
      def with_display_lifecycle: (Class root_task_class) { () -> void } -> void
      def setup_progress_display: (Class root_task_class) -> void
      def setup_output_capture_if_needed: () -> bool
      def teardown_output_capture: () -> void
      def start_progress_display: () -> void
      def stop_progress_display: () -> void
      def raise_if_any_failures: () -> void
      def raise_if_any_clean_failures: () -> void
      def raise_if_any_failures_from: (Array[TaskWrapper] failed_wrappers, error_accessor: ^(TaskWrapper) -> StandardError?) -> void
      def flatten_failures_from: (Array[TaskWrapper] failed_wrappers, error_accessor: ^(TaskWrapper) -> StandardError?) -> Array[TaskFailure]
      def wrap_with_task_error: (Class task_class, Exception error) -> TaskError
      def error_identity: (Exception error) -> Integer
      def create_default_execution_context: () -> ExecutionContext
      def log_execution_started: (Class root_task_class) -> void
      def log_execution_completed: (Class root_task_class, Time start_time) -> void
      def default_worker_count: () -> Integer
      def debug_log: (String message) -> void
    end

    # SharedState provides centralized, thread-safe state management
    # for the Fiber-based executor
    class SharedState
      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol
      STATE_ERROR: Symbol

      @mutex: Mutex
      @states: Hash[Class, Symbol]
      @wrappers: Hash[Class, TaskWrapper]
      @errors: Hash[Class, Exception]
      @waiters: Hash[Class, Array[Array[untyped]]]

      def initialize: () -> void
      def register: (Class task_class, TaskWrapper wrapper) -> void
      def mark_running: (Class task_class) -> bool
      def mark_completed: (Class task_class) -> void
      def mark_failed: (Class task_class, Exception error) -> void
      def completed?: (Class task_class) -> bool
      def get_wrapper: (Class task_class) -> TaskWrapper?
      def request_dependency: (Class dep_class, Symbol method, Thread::Queue thread_queue, Fiber fiber) -> Array[untyped]

      private

      def notify_waiters: (Class task_class, Array[Array[untyped]] waiters) -> void
    end

    # TaskWrapper class for task execution
    class TaskWrapper
      attr_reader task: Task
      attr_reader result: untyped
      attr_reader error: StandardError?
      attr_reader clean_error: StandardError?
      attr_reader timing: TaskTiming?

      @task: Task
      @registry: Registry
      @execution_context: ExecutionContext?
      @result: untyped
      @clean_result: untyped
      @error: StandardError?
      @clean_error: StandardError?
      @monitor: Monitor
      @condition: MonitorMixin::ConditionVariable
      @clean_condition: MonitorMixin::ConditionVariable
      @state: Symbol
      @clean_state: Symbol
      @timing: TaskTiming?

      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol
      STATE_FAILED: Symbol

      def initialize: (Task task, registry: Registry, ?execution_context: ExecutionContext?) -> void
      def state: () -> Symbol
      def pending?: () -> bool
      def completed?: () -> bool
      def failed?: () -> bool
      def clean_failed?: () -> bool
      def run: () -> untyped
      def clean: () -> untyped
      def run_and_clean: () -> untyped
      def get_exported_value: (Symbol method_name) -> untyped
      def mark_running: () -> bool
      def mark_completed: (untyped result) -> void
      def mark_failed: (StandardError error) -> void
      def mark_clean_running: () -> bool
      def mark_clean_completed: (untyped result) -> void
      def mark_clean_failed: (StandardError error) -> void
      def wait_for_completion: () -> void
      def wait_for_clean_completion: () -> void
      def method_missing: (Symbol name, *untyped args) ?{ (*untyped) -> untyped } -> untyped
      def respond_to_missing?: (Symbol name, ?bool include_private) -> bool

      private

      def trigger_execution_and_wait: () -> void
      def trigger_clean_and_wait: () -> void
      def execute_clean: () -> void
      def wait_for_clean_dependencies: () -> void
      def check_abort!: () -> void
      def update_progress: (Symbol state, ?duration: Numeric?, ?error: Exception?) -> void
      def debug_log: (String message) -> void
    end
  end

  # Progress module
  module Progress
    module Layout
      # Base class for progress display layouts
      class Base
      end
    end
  end

  # StaticAnalysis module
  module StaticAnalysis
    # Analyzer class for dependency analysis
    class Analyzer
      def self.analyze: (Class task_class) -> Set[task_class]

      private

      def self.extract_method_location: (Class task_class, Symbol method_name) -> [String, Integer]?
    end

    # Visitor class for AST traversal
    class Visitor < Prism::Visitor
      @target_task_class: Class
      @target_method: Symbol
      @dependencies: Set[task_class]
      @in_target_method: bool
      @current_namespace_path: Array[String?]

      attr_reader dependencies: Set[task_class]

      def initialize: (Class task_class, ?Symbol target_method, ?Array[Symbol]? methods_to_analyze) -> void
      def visit_class_node: (Prism::ClassNode node) -> untyped
      def visit_module_node: (Prism::ModuleNode node) -> untyped
      def visit_def_node: (Prism::DefNode node) -> untyped
      def visit_call_node: (Prism::CallNode node) -> untyped

      private

      def follow_method_calls: () -> void
      def collect_method_definitions: (Prism::ClassNode class_node) -> void
      def within_namespace: (String? name) { () -> void } -> void
      def in_target_class?: () -> bool
      def extract_constant_name: (untyped node) -> String?
      def should_analyze_method?: (Symbol method_name) -> bool
      def detect_method_call_to_follow: (Prism::CallNode node) -> void
      def self_receiver?: (untyped receiver) -> bool
      def detect_task_dependency: (Prism::CallNode node) -> void
      def extract_receiver_constant: (untyped receiver) -> String?
      def resolve_and_add_dependency: (String constant_name) -> void
      def resolve_constant: (String name) -> task_class?
      def resolve_with_namespace_prefix: (String name) -> task_class?
      def valid_dependency?: (task_class klass) -> bool
    end

    # DependencyGraph class for topological sorting and cycle detection
    class DependencyGraph
      include TSort[Class]

      @graph: Hash[Class, Set[Class]]

      def initialize: () -> void
      def build_from: (Class root_task_class) -> self
      def sorted: () -> Array[Class]
      def cyclic?: () -> bool
      def strongly_connected_components: () -> Array[Array[Class]]
      def cyclic_components: () -> Array[Array[Class]]
      def all_tasks: () -> Array[Class]
      def dependencies_for: (Class task) -> Set[Class]

      # TSort interface methods (required by TSort module)
      def tsort_each_node: () { (Class) -> void } -> void
      def tsort_each_child: (Class node) { (Class) -> void } -> void

      private

      def collect_dependencies: (Class task_class) -> void
    end
  end
end
