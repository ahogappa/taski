module Taski
  VERSION: String

  self.@global_registry: Execution::Registry?
  self.@progress_display: Execution::ParallelProgressDisplay?

  # Type alias for Task class (singleton type with class methods)
  # This represents a Class that inherits from Taski::Task
  type task_class = singleton(Task)

  # Module-level methods
  def self.global_registry: () -> Execution::Registry
  def self.reset_global_registry!: () -> void
  def self.progress_display: () -> Execution::ParallelProgressDisplay?
  def self.progress_enabled?: () -> bool
  def self.reset_progress_display!: () -> void

  # Custom exceptions
  class TaskAbortException < StandardError
  end

  class CircularDependencyError < StandardError
    @cyclic_tasks: Array[Array[Class]]

    attr_reader cyclic_tasks: Array[Array[Class]]

    def initialize: (Array[Array[Class]] cyclic_tasks) -> void
  end

  # Context class for execution context management
  class Context
    self.@monitor: Monitor
    self.@working_directory: String?
    self.@started_at: Time?
    self.@root_task: Class?

    def self.working_directory: () -> String
    def self.started_at: () -> Time
    def self.root_task: () -> Class?
    def self.set_root_task: (Class task) -> void
    def self.reset!: () -> void
  end

  # Main Task class
  class Task
    self.@exported_methods: Array[Symbol]
    self.@dependencies_cache: Set[task_class]?
    self.@coordinator: Execution::Coordinator?
    self.@circular_dependency_checked: bool

    # Class methods
    def self.exports: (*Symbol names) -> void
    def self.exported_methods: () -> Array[Symbol]
    def self.new: () -> Execution::TaskWrapper
    def self.cached_dependencies: () -> Set[task_class]
    def self.clear_dependency_cache: () -> void
    def self.run: () -> untyped
    def self.clean: () -> void
    def self.registry: () -> Execution::Registry
    def self.coordinator: () -> Execution::Coordinator
    def self.reset!: () -> void
    def self.tree: () -> String

    # Instance methods
    def run: () -> void
    def clean: () -> void
    def reset!: () -> void

    private

    # Private class methods
    def self.build_tree: (task_class task_class, String prefix, Set[task_class] visited) -> String
    def self.format_dependency_branch: (task_class dep, String prefix, bool is_last, Set[task_class] visited) -> String
    def self.tree_connector_chars: (bool is_last) -> [String, String]
    def self.cached_wrapper: () -> Execution::TaskWrapper
    def self.define_instance_reader: (Symbol method_name) -> void
    def self.define_class_accessor: (Symbol method_name) -> void
    def self.validate_no_circular_dependencies!: () -> void
  end

  # Section class for abstraction layers (inherits from Task)
  class Section < Task
    def self.interfaces: (*Symbol interface_methods) -> void

    def run: () -> void
    def impl: () -> task_class

    private

    def apply_interface_to_implementation: (task_class implementation_class) -> void
  end

  # Execution module
  module Execution
    # TaskTiming struct (Data.define)
    class TaskTiming
      attr_reader start_time: Time
      attr_reader end_time: Time?

      # Data.define provides both positional and keyword argument constructors
      def initialize: (Time start_time, Time? end_time) -> void
                    | (start_time: Time, end_time: Time?) -> void

      def self.new: (Time start_time, Time? end_time) -> TaskTiming
                  | (start_time: Time, end_time: Time?) -> TaskTiming

      def self.start_now: () -> TaskTiming
      def duration_ms: () -> (Integer | Float)?
      def with_end_now: () -> TaskTiming
      def with: (?start_time: Time, ?end_time: Time?) -> TaskTiming
    end

    # Registry class for task instance management
    class Registry
      @tasks: Hash[Class, TaskWrapper]
      @threads: Array[Thread]
      @monitor: Monitor
      @abort_requested: bool

      def initialize: () -> void
      def get_or_create: (Class task_class) { () -> TaskWrapper } -> TaskWrapper
      def get_task: (Class task_class) -> TaskWrapper
      def register_thread: (Thread thread) -> void
      def wait_all: () -> void
      def reset!: () -> void
      def request_abort!: () -> void
      def abort_requested?: () -> bool
      def run: (Class task_class, Array[Symbol] exported_methods) -> untyped
    end

    # Coordinator class for dependency management
    class Coordinator
      @registry: Registry
      @analyzer: singleton(StaticAnalysis::Analyzer)

      def initialize: (registry: Registry, analyzer: singleton(StaticAnalysis::Analyzer)) -> void
      def start_dependencies: (task_class task_class) -> void
      def start_clean_dependencies: (task_class task_class) -> void
      def get_dependencies: (task_class task_class) -> Set[task_class]

      private

      def start_thread_with: () { () -> void } -> void
      def start_dependency_execution: (task_class dep_class) -> void
      def start_dependency_clean: (task_class dep_class) -> void
    end

    # TaskWrapper class for task execution
    class TaskWrapper
      attr_reader task: Task
      attr_reader result: untyped

      @task: Task
      @registry: Registry
      @coordinator: Coordinator
      @result: untyped
      @clean_result: untyped
      @error: StandardError?
      @monitor: Monitor
      @condition: MonitorMixin::ConditionVariable
      @clean_condition: MonitorMixin::ConditionVariable
      @state: Symbol
      @clean_state: Symbol
      @timing: TaskTiming?

      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol

      def initialize: (Task task, registry: Registry, coordinator: Coordinator) -> void
      def run: () -> untyped
      def clean: () -> void
      def get_exported_value: (Symbol method_name) -> untyped
      def start_thread_with: () { () -> void } -> void
      def execute_with_state_pattern: (state_getter: ^() -> Symbol, starter: ^() -> void, waiter: ^() -> void, ?pre_start_check: (^() -> void)?) -> void
      def execute_task_if_needed: () -> void
      def start_async_execution: () -> void
      def execute_task: () -> void
      def wait_for_dependencies: () -> void
      def execute_clean_if_needed: () -> void
      def start_async_clean: () -> void
      def execute_clean: () -> void
      def wait_for_clean_dependencies: () -> void
      def mark_completed: () -> void
      def mark_clean_completed: () -> void
      def wait_for_completion: () -> untyped
      def wait_for_clean_completion: () -> void
      def debug_log: (String message) -> void
      def log_start: () -> void
      def log_completion: () -> void
      def log_clean_start: () -> void
      def log_clean_completion: () -> void
      def register_with_progress_display: () -> void
      def update_progress: (Symbol state, ?duration: Numeric?, ?error: Exception?) -> void
      def method_missing: (Symbol name, *untyped args) ?{ (*untyped) -> untyped } -> untyped
      def respond_to_missing?: (Symbol name, ?bool include_private) -> bool
    end

    # ParallelProgressDisplay class for progress visualization
    class ParallelProgressDisplay
      SPINNER_FRAMES: Array[String]

      @output: IO
      @tasks: Hash[Class, TaskProgress]
      @monitor: Monitor
      @spinner_index: Integer
      @renderer_thread: Thread?
      @running: bool

      class TaskProgress
        attr_accessor state: Symbol
        attr_accessor start_time: Time?
        attr_accessor end_time: Time?
        attr_accessor error: Exception?
        attr_accessor duration: Numeric?

        def initialize: () -> void
      end

      def initialize: (?output: IO) -> void
      def register_task: (Class task_class) -> void
      def task_registered?: (Class task_class) -> bool
      def update_task: (Class task_class, state: Symbol, ?duration: Numeric?, ?error: Exception?) -> void
      def task_state: (Class task_class) -> Symbol?
      def render: () -> void
      def start: () -> void
      def stop: () -> void

      private

      def collect_task_lines: () -> Array[String]
      def render_live: () -> void
      def render_final: () -> void
      def format_task_line: (Class task_class, TaskProgress progress) -> String
      def task_icon: (Symbol state) -> String
      def spinner_char: () -> String
      def task_details: (TaskProgress progress) -> String
    end
  end

  # StaticAnalysis module
  module StaticAnalysis
    # Analyzer class for dependency analysis
    class Analyzer
      def self.analyze: (Class task_class) -> Set[task_class]

      private

      def self.extract_run_method_location: (Class task_class) -> [String, Integer]?
    end

    # Visitor class for AST traversal
    class Visitor < Prism::Visitor
      @target_task_class: Class
      @dependencies: Set[task_class]
      @in_target_run_method: bool
      @current_namespace_path: Array[String?]

      attr_reader dependencies: Set[task_class]

      def initialize: (Class task_class) -> void
      def visit_class_node: (Prism::ClassNode node) -> untyped
      def visit_module_node: (Prism::ModuleNode node) -> untyped
      def visit_def_node: (Prism::DefNode node) -> untyped
      def visit_call_node: (Prism::CallNode node) -> untyped

      private

      def within_namespace: (String? name) { () -> void } -> void
      def in_target_class?: () -> bool
      def extract_constant_name: (untyped node) -> String?
      def detect_task_dependency: (Prism::CallNode node) -> void
      def extract_receiver_constant: (untyped receiver) -> String?
      def resolve_and_add_dependency: (String constant_name) -> void
      def resolve_constant: (String name) -> task_class?
      def resolve_with_namespace_prefix: (String name) -> task_class?
      def valid_dependency?: (task_class klass) -> bool
      def is_parallel_task?: (task_class klass) -> boolish
      def is_parallel_section?: (task_class klass) -> boolish
    end

    # DependencyGraph class for topological sorting and cycle detection
    class DependencyGraph
      include TSort[Class]

      @graph: Hash[Class, Set[Class]]

      def initialize: () -> void
      def build_from: (Class root_task_class) -> self
      def sorted: () -> Array[Class]
      def cyclic?: () -> bool
      def strongly_connected_components: () -> Array[Array[Class]]
      def cyclic_components: () -> Array[Array[Class]]
      def all_tasks: () -> Array[Class]
      def dependencies_for: (Class task) -> Set[Class]

      # TSort interface methods (required by TSort module)
      def tsort_each_node: () { (Class) -> void } -> void
      def tsort_each_child: (Class node) { (Class) -> void } -> void

      private

      def collect_dependencies: (Class task_class) -> void
    end
  end
end
