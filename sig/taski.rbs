module Taski
  VERSION: String

  NOT_CONFIGURED: Object
  self.@progress_display: Progress::Layout::Base | Object | nil
  self.@args: Args?
  self.@args_monitor: Monitor

  # Type alias for Task class (singleton type with class methods)
  # This represents a Class that inherits from Taski::Task
  type task_class = singleton(Task)
  def self.progress_display: () -> (Progress::Layout::Base | untyped)?
  def self.progress_display=: (untyped display) -> void
  def self.reset_progress_display!: () -> void
  def self.args: () -> Args?
  def self.start_args: (options: Hash[Symbol, untyped]) -> void
  def self.reset_args!: () -> void
  def self.args_worker_count: () -> Integer?

  # Custom exceptions
  class TaskAbortException < StandardError
  end

  class CircularDependencyError < StandardError
    @cyclic_tasks: Array[Array[Class]]

    attr_reader cyclic_tasks: Array[Array[Class]]

    def initialize: (Array[Array[Class]] cyclic_tasks) -> void
  end

  # Represents a single task failure with its context
  class TaskFailure
    @task_class: Class
    @error: Exception
    @output_lines: Array[String]

    attr_reader task_class: Class
    attr_reader error: Exception
    attr_reader output_lines: Array[String]

    def initialize: (task_class: Class, error: Exception, ?output_lines: Array[String]) -> void
  end

  # Mixin for exception classes to enable transparent rescue matching with AggregateError
  module AggregateAware
    def ===: (untyped other) -> bool
  end

  # Base class for task-specific error wrappers
  class TaskError < StandardError
    extend AggregateAware

    @cause: Exception
    @task_class: Class

    attr_reader cause: Exception
    attr_reader task_class: Class

    def initialize: (Exception cause, task_class: Class) -> void
  end

  # Raised when multiple tasks fail during parallel execution
  class AggregateError < StandardError
    @errors: Array[TaskFailure]

    attr_reader errors: Array[TaskFailure]

    def initialize: (Array[TaskFailure] errors) -> void
    def cause: () -> Exception?
    def includes?: (Class exception_class) -> bool

    private

    def build_message: () -> String
  end

  # Args class for execution arguments management
  class Args
    @options: Hash[Symbol | String, untyped]

    def initialize: (options: Hash[Symbol | String, untyped]) -> void
    def []: (Symbol | String key) -> untyped
    def fetch: (Symbol | String key, ?untyped default) ?{ () -> untyped } -> untyped
    def key?: (Symbol | String key) -> bool
  end

  # Main Task class
  class Task
    self.@exported_methods: Array[Symbol]
    self.@dependencies_cache: Set[task_class]?
    self.@circular_dependency_checked: bool

    # Class methods
    def self.inherited: (Class subclass) -> void
    def self.exports: (*Symbol names) -> void
    def self.exported_methods: () -> Array[Symbol]
    def self.new: () -> Execution::TaskWrapper
    def self.cached_dependencies: () -> Set[task_class]
    def self.clear_dependency_cache: () -> void
    def self.run: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> untyped
    def self.clean: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> void
    def self.run_and_clean: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> untyped
    def self.registry: () -> Execution::Registry
    def self.reset!: () -> void
    def self.tree: () -> String

    # Instance methods
    def run: () -> void
    def clean: () -> void
    def group: (String name) { () -> untyped } -> untyped
    def system: (*untyped args, **untyped opts) -> bool?
    def reset!: () -> void

    private

    # Private class methods
    def self.cached_wrapper: () -> Execution::TaskWrapper
    def self.define_instance_reader: (Symbol method_name) -> void
    def self.define_class_accessor: (Symbol method_name) -> void
    def self.validate_no_circular_dependencies!: () -> void
    def self.validate_workers!: (untyped workers) -> void
  end

  # Execution module
  module Execution
    # Base class for observers of the execution lifecycle
    class TaskObserver
      attr_accessor context: ExecutionFacade?

      def on_ready: () -> void
      def on_start: () -> void
      def on_stop: () -> void
      def on_task_updated: (Class task_class, previous_state: Symbol?, current_state: Symbol, phase: Symbol, timestamp: Time) -> void
      def on_group_started: (Class task_class, String group_name, phase: Symbol, timestamp: Time) -> void
      def on_group_completed: (Class task_class, String group_name, phase: Symbol, timestamp: Time) -> void
    end

    # Registry class for task instance management
    class Registry
      @tasks: Hash[Class, TaskWrapper]
      @threads: Array[Thread]
      @monitor: Monitor
      @abort_requested: bool

      def initialize: () -> void
      def get_or_create: (Class task_class) { () -> TaskWrapper } -> TaskWrapper
      def create_wrapper: (Class task_class, execution_facade: ExecutionFacade) -> TaskWrapper
      def register: (Class task_class, TaskWrapper wrapper) -> void
      def register_thread: (Thread thread) -> void
      def wait_all: () -> void
      def reset!: () -> void
      def request_abort!: () -> void
      def abort_requested?: () -> bool
      def registered?: (Class task_class) -> bool
      def failed_wrappers: () -> Array[TaskWrapper]
      def failed_clean_wrappers: () -> Array[TaskWrapper]
    end

    # ExecutionFacade is the central hub for execution events with both Push and Pull APIs
    class ExecutionFacade
      THREAD_LOCAL_KEY: Symbol

      attr_reader root_task_class: Class?
      attr_reader dependency_graph: StaticAnalysis::DependencyGraph?

      @root_task_class: Class?
      @dependency_graph: StaticAnalysis::DependencyGraph?
      @output_stream: untyped
      @monitor: Monitor
      @observers: Array[untyped]
      @execution_trigger: (^(Class, Registry) -> void)?
      @clean_trigger: (^(Class, Registry) -> void)?
      @output_capture: TaskOutputRouter?
      @original_stdout: IO?
      @original_stderr: IO?

      def self.current: () -> ExecutionFacade?
      def self.current=: (ExecutionFacade? context) -> void

      def initialize: (root_task_class: Class, ?output_stream: untyped) -> void
      def output_stream: () -> untyped
      def output_capture_active?: () -> bool
      def original_stdout: () -> IO?
      def original_stderr: () -> IO?
      def setup_output_capture: (IO output_io) -> void
      def teardown_output_capture: () -> void
      def output_capture: () -> TaskOutputRouter?
      def execution_trigger=: ((^(Class, Registry) -> void)? trigger) -> void
      def clean_trigger=: ((^(Class, Registry) -> void)? trigger) -> void
      def trigger_execution: (Class task_class, registry: Registry) -> void
      def trigger_clean: (Class task_class, registry: Registry) -> untyped
      def add_observer: (untyped observer) -> void
      def remove_observer: (untyped observer) -> void
      def observers: () -> Array[untyped]
      def notify_ready: () -> void
      def notify_start: () -> void
      def notify_stop: () -> void
      def notify_task_updated: (Class task_class, previous_state: Symbol?, current_state: Symbol, phase: Symbol, timestamp: Time) -> void
      def notify_group_started: (Class task_class, String group_name, phase: Symbol, timestamp: Time) -> void
      def notify_group_completed: (Class task_class, String group_name, phase: Symbol, timestamp: Time) -> void

      private

      def dispatch: (Symbol method_name, *untyped args, **untyped kwargs) -> void
    end

    # TaskOutputRouter for routing task output
    class TaskOutputRouter
      def initialize: (IO original_io, ?ExecutionFacade? execution_facade) -> void
      def current_write_io: () -> IO?
      def start_capture: (Class task_class) -> void
      def stop_capture: () -> void
      def read: (Class task_class, ?limit: Integer?) -> Array[String]
    end

    # Scheduler manages task dependency state and determines execution order
    class Scheduler
      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol
      STATE_FAILED: Symbol
      STATE_SKIPPED: Symbol

      @dependencies: Hash[Class, Array[Class]]
      @task_states: Hash[Class, Symbol]
      @finished_tasks: Set[Class]
      @run_reverse_deps: Hash[Class, Set[Class]]
      @reverse_dependencies: Hash[Class, Set[Class]]
      @clean_task_states: Hash[Class, Symbol]
      @clean_finished_tasks: Set[Class]

      def initialize: () -> void
      def load_graph: (StaticAnalysis::DependencyGraph dependency_graph, Class root_task_class) -> void
      def next_ready_tasks: () -> Array[Class]
      def mark_running: (Class task_class) -> void
      def mark_completed: (Class task_class) -> void
      def mark_failed: (Class task_class) -> void
      def completed?: (Class task_class) -> bool
      def running_tasks?: () -> bool
      def task_count: () -> Integer
      def skipped_task_classes: () -> Array[Class]
      def mark_skipped: (Class task_class) -> bool
      def skipped_count: () -> Integer
      def was_executed?: (Class task_class) -> bool
      def pending_dependents_of: (Class task_class) -> Array[Class]
      def build_reverse_dependency_graph: () -> void
      def next_ready_clean_tasks: () -> Array[Class]
      def mark_clean_running: (Class task_class) -> void
      def mark_clean_completed: (Class task_class) -> void
      def mark_clean_failed: (Class task_class) -> void
      def clean_completed?: (Class task_class) -> bool
      def running_clean_tasks?: () -> bool

      private

      def ready_to_execute?: (Class task_class) -> bool
      def ready_to_clean?: (Class task_class) -> bool
    end

    def self.default_worker_count: () -> Integer

    # WorkerPool manages N threads, each with its own command Queue
    # Tasks are executed within Fibers on worker threads
    class WorkerPool
      attr_reader worker_count: Integer

      @registry: Registry
      @execution_facade: ExecutionFacade
      @worker_count: Integer
      @completion_queue: Thread::Queue
      @threads: Array[Thread]
      @thread_queues: Array[Thread::Queue]
      @next_thread_index: Integer
      @fiber_contexts_mutex: Mutex
      @fiber_contexts: Hash[Integer, Array[untyped]]
      @task_start_times: Hash[Class, Time]

      def initialize: (registry: Registry, execution_facade: ExecutionFacade, completion_queue: Thread::Queue, ?worker_count: Integer?) -> void
      def start: () -> void
      def enqueue: (Class task_class, TaskWrapper wrapper) -> void
      def enqueue_clean: (Class task_class, TaskWrapper wrapper) -> void
      def shutdown: () -> void

      private

      def worker_loop: (Thread::Queue queue) -> void
      def drive_fiber: (Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def drive_fiber_loop: (Fiber fiber, Class task_class, TaskWrapper wrapper, Thread::Queue queue, ?untyped resume_value) -> void
      def handle_dependency: (Class dep_class, Symbol method, Fiber fiber, Class task_class, TaskWrapper wrapper, Thread::Queue queue) -> void
      def resume_fiber: (Fiber fiber, untyped value, Thread::Queue queue) -> void
      def resume_fiber_with_error: (Fiber fiber, Exception error, Thread::Queue queue) -> void
      def start_dependency: (Class dep_class, TaskWrapper dep_wrapper, Thread::Queue queue) -> void
      def complete_task: (Class task_class, TaskWrapper wrapper, untyped result) -> void
      def fail_task: (Class task_class, TaskWrapper wrapper, Exception error) -> void
      def execute_clean_task: (Class task_class, TaskWrapper wrapper) -> void
      def setup_clean_thread_locals: () -> void
      def setup_run_thread_locals: () -> void
      def teardown_thread_locals: () -> void
      def start_output_capture: (Class task_class) -> void
      def stop_output_capture: () -> void
      def store_fiber_context: (Fiber fiber, Class task_class, TaskWrapper wrapper) -> void
      def get_fiber_context: (Fiber fiber) -> Array[untyped]?
      def task_duration_ms: (Class task_class) -> Float?
    end

    # Executor orchestrates both run and clean phases of task execution
    # Both run and clean phases use WorkerPool
    class Executor
      @registry: Registry
      @completion_queue: Thread::Queue
      @execution_facade: ExecutionFacade
      @scheduler: Scheduler
      @effective_worker_count: Integer?
      @enqueued_tasks: Set[Class]
      @worker_pool: WorkerPool?
      @saved_output_capture: TaskOutputRouter?

      def self.execute: (Class root_task_class, registry: Registry, ?execution_facade: ExecutionFacade?) -> void
      def self.execute_clean: (Class root_task_class, registry: Registry, ?execution_facade: ExecutionFacade?) -> void
      def initialize: (?root_task_class: Class?, registry: Registry, ?worker_count: Integer?, ?execution_facade: ExecutionFacade?) -> void
      def execute: (Class root_task_class) -> void
      def execute_clean: (Class root_task_class) -> void

      private

      def resolve_dependency_graph: (Class root_task_class) -> StaticAnalysis::DependencyGraph
      def pre_start_leaf_tasks: () -> void
      def enqueue_root_if_needed: (Class root_task_class) -> void
      def run_main_loop: (Class root_task_class) -> void
      def handle_completion: (Hash[Symbol, untyped] event) -> void
      def enqueue_for_execution: (Class task_class) -> void
      def skip_pending_dependents: (Class failed_task_class) -> void
      def notify_skipped_tasks: () -> void
      def enqueue_ready_clean_tasks: () -> void
      def enqueue_clean_task: (Class task_class) -> void
      def run_clean_main_loop: () -> void
      def handle_clean_completion: (Hash[Symbol, untyped] event) -> void
      def all_tasks_cleaned?: () -> bool
      def with_display_lifecycle: (Class root_task_class) { () -> void } -> void
      def setup_output_capture_if_needed: () -> bool
      def raise_if_any_failures: () -> void
      def raise_if_any_clean_failures: () -> void
      def raise_if_any_failures_from: (Array[TaskWrapper] failed_wrappers, error_accessor: ^(TaskWrapper) -> StandardError?) -> void
      def flatten_failures_from: (Array[TaskWrapper] failed_wrappers, error_accessor: ^(TaskWrapper) -> StandardError?) -> Array[TaskFailure]
      def wrap_with_task_error: (Class task_class, Exception error) -> TaskError
      def error_identity: (Exception error) -> Integer
      def create_default_facade: () -> ExecutionFacade
      def log_execution_started: (Class root_task_class) -> void
      def log_execution_completed: (Class root_task_class, Time start_time) -> void
      def log_error_detail: (Class task_class, Exception error) -> void
    end

    # TaskWrapper class for task execution
    class TaskWrapper
      attr_reader task: Task
      attr_reader result: untyped
      attr_reader error: StandardError?
      attr_reader clean_error: StandardError?

      @task: Task
      @registry: Registry
      @execution_facade: ExecutionFacade?
      @args: Hash[Symbol, untyped]?
      @result: untyped
      @clean_result: untyped
      @error: StandardError?
      @clean_error: StandardError?
      @monitor: Monitor
      @condition: MonitorMixin::ConditionVariable
      @clean_condition: MonitorMixin::ConditionVariable
      @state: Symbol
      @clean_state: Symbol
      @waiters: Array[Array[untyped]]

      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol
      STATE_FAILED: Symbol
      STATE_SKIPPED: Symbol

      def initialize: (Task task, registry: Registry, ?execution_facade: ExecutionFacade?, ?args: Hash[Symbol, untyped]?) -> void
      def state: () -> Symbol
      def pending?: () -> bool
      def completed?: () -> bool
      def failed?: () -> bool
      def skipped?: () -> bool
      def run: () -> untyped
      def clean: () -> untyped
      def reset!: () -> void
      def run_and_clean: () ?{ () -> void } -> untyped
      def get_exported_value: (Symbol method_name) -> untyped
      def request_value: (Symbol method, Thread::Queue thread_queue, Fiber fiber) -> Array[untyped]
      def mark_running: () -> bool
      def mark_completed: (untyped result) -> void
      def mark_failed: (StandardError error) -> void
      def mark_skipped: () -> bool
      def mark_clean_running: () -> bool
      def mark_clean_completed: (untyped result) -> void
      def mark_clean_failed: (StandardError error) -> void
      def wait_for_completion: () -> void
      def wait_for_clean_completion: () -> void
      def method_missing: (Symbol name, *untyped args) ?{ (*untyped) -> untyped } -> untyped
      def respond_to_missing?: (Symbol name, ?bool include_private) -> bool

      private

      def with_args_lifecycle: [T] () { () -> T } -> T
      def trigger_execution_and_wait: () -> void
      def trigger_clean_and_wait: () -> void
      def trigger_and_wait: (state_accessor: ^() -> Symbol, condition: MonitorMixin::ConditionVariable, trigger: ^(ExecutionFacade) -> void) -> void
      def check_abort!: () -> void
      def ensure_execution_facade: () -> ExecutionFacade
      def create_shared_context: () -> ExecutionFacade
      def notify_skipped: () -> void
      def update_progress: (Symbol state, ?error: Exception?) -> void
      def update_clean_progress: (Symbol state, ?error: Exception?) -> void
      def notify_state_change: (previous_state: Symbol?, current_state: Symbol, phase: Symbol) -> void
      def notify_fiber_waiters_completed: (Array[Array[untyped]] waiters) -> void
      def notify_fiber_waiters_failed: (Array[Array[untyped]] waiters, Exception error) -> void
    end
  end

  # Progress module
  module Progress
    module Layout
      # Base class for progress display layouts
      class Base < Execution::TaskObserver
      end
    end
  end

  # StaticAnalysis module
  module StaticAnalysis
    # Analyzer class for dependency analysis
    class Analyzer
      def self.analyze: (Class task_class) -> Set[task_class]

      private

      def self.extract_method_location: (Class task_class, Symbol method_name) -> [String, Integer]?
    end

    # Visitor class for AST traversal
    class Visitor < Prism::Visitor
      @target_task_class: Class
      @target_method: Symbol
      @dependencies: Set[task_class]
      @in_target_method: bool
      @current_namespace_path: Array[String?]

      attr_reader dependencies: Set[task_class]

      def initialize: (Class task_class, ?Symbol target_method, ?Array[Symbol]? methods_to_analyze) -> void
      def visit_class_node: (Prism::ClassNode node) -> untyped
      def visit_module_node: (Prism::ModuleNode node) -> untyped
      def visit_def_node: (Prism::DefNode node) -> untyped
      def visit_call_node: (Prism::CallNode node) -> untyped

      private

      def follow_method_calls: () -> void
      def collect_method_definitions: (Prism::ClassNode class_node) -> void
      def within_namespace: (String? name) { () -> void } -> void
      def in_target_class?: () -> bool
      def extract_constant_name: (untyped node) -> String?
      def should_analyze_method?: (Symbol method_name) -> bool
      def detect_method_call_to_follow: (Prism::CallNode node) -> void
      def self_receiver?: (untyped receiver) -> bool
      def detect_task_dependency: (Prism::CallNode node) -> void
      def extract_receiver_constant: (untyped receiver) -> String?
      def resolve_and_add_dependency: (String constant_name) -> void
      def resolve_constant: (String name) -> task_class?
      def resolve_with_namespace_prefix: (String name) -> task_class?
      def valid_dependency?: (task_class klass) -> bool
    end

    # DependencyGraph class for topological sorting and cycle detection
    class DependencyGraph
      include TSort[Class]

      @graph: Hash[Class, Set[Class]]

      def initialize: () -> void
      def build_from: (Class root_task_class) -> self
      def build_from_cached: (Class root_task_class) -> self
      def sorted: () -> Array[Class]
      def cyclic?: () -> bool
      def strongly_connected_components: () -> Array[Array[Class]]
      def cyclic_components: () -> Array[Array[Class]]
      def all_tasks: () -> Array[Class]
      def dependencies_for: (Class task) -> Set[Class]

      # TSort interface methods (required by TSort module)
      def tsort_each_node: () { (Class) -> void } -> void
      def tsort_each_child: (Class node) { (Class) -> void } -> void

      private

      def collect_dependencies: (Class task_class) -> void
      def collect_cached_dependencies: (Class task_class) -> void
    end
  end

  # Logging module
  module Logging
    module Events
      EXECUTION_STARTED: String
      EXECUTION_COMPLETED: String
      TASK_STARTED: String
      TASK_COMPLETED: String
      TASK_FAILED: String
      TASK_CLEAN_STARTED: String
      TASK_CLEAN_COMPLETED: String
      TASK_CLEAN_FAILED: String
      TASK_SKIPPED: String
      DEPENDENCY_RESOLVED: String
      TASK_ERROR_DETAIL: String
      TASK_OUTPUT: String
      WORKER_POOL_ENQUEUED: String
      EXECUTOR_TASK_COMPLETED: String
      EXECUTOR_CLEAN_COMPLETED: String
      OUTPUT_ROUTER_START_CAPTURE: String
      OUTPUT_ROUTER_STOP_CAPTURE: String
      OUTPUT_ROUTER_STOP_CAPTURE_UNREGISTERED: String
      OUTPUT_ROUTER_DRAIN_PIPE: String
      OUTPUT_ROUTER_STORE_LINES: String
      OBSERVER_ERROR: String
    end

  end
end
