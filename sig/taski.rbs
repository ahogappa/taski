module Taski
  VERSION: String

  self.@global_registry: Execution::Registry?
  self.@progress_display: Execution::TreeProgressDisplay?
  self.@args: Args?
  self.@args_monitor: Monitor

  # Type alias for Task class (singleton type with class methods)
  # This represents a Class that inherits from Taski::Task
  type task_class = singleton(Task)

  # Module-level methods
  def self.global_registry: () -> Execution::Registry
  def self.reset_global_registry!: () -> void
  def self.progress_display: () -> Execution::TreeProgressDisplay?
  def self.progress_disabled?: () -> bool
  def self.reset_progress_display!: () -> void
  def self.args: () -> Args?
  def self.start_args: (options: Hash[Symbol, untyped], root_task: Class) -> void
  def self.reset_args!: () -> void
  def self.args_worker_count: () -> Integer?

  # Custom exceptions
  class TaskAbortException < StandardError
  end

  class CircularDependencyError < StandardError
    @cyclic_tasks: Array[Array[Class]]

    attr_reader cyclic_tasks: Array[Array[Class]]

    def initialize: (Array[Array[Class]] cyclic_tasks) -> void
  end

  # Represents a single task failure with its context
  class TaskFailure
    @task_class: Class
    @error: Exception

    attr_reader task_class: Class
    attr_reader error: Exception

    def initialize: (task_class: Class, error: Exception) -> void
  end

  # Mixin for exception classes to enable transparent rescue matching with AggregateError
  module AggregateAware
    def ===: (untyped other) -> bool
  end

  # Base class for task-specific error wrappers
  class TaskError < StandardError
    extend AggregateAware

    @cause: Exception
    @task_class: Class

    attr_reader cause: Exception
    attr_reader task_class: Class

    def initialize: (Exception cause, task_class: Class) -> void
  end

  # Raised when multiple tasks fail during parallel execution
  class AggregateError < StandardError
    @errors: Array[TaskFailure]

    attr_reader errors: Array[TaskFailure]

    def initialize: (Array[TaskFailure] errors) -> void
    def cause: () -> Exception?
    def includes?: (Class exception_class) -> bool

    private

    def build_message: () -> String
  end

  # Args class for execution arguments management
  class Args
    @options: Hash[Symbol | String, untyped]
    @root_task: Class
    @started_at: Time
    @working_directory: String

    attr_reader started_at: Time
    attr_reader working_directory: String
    attr_reader root_task: Class

    def initialize: (options: Hash[Symbol | String, untyped], root_task: Class) -> void
    def []: (Symbol | String key) -> untyped
    def fetch: (Symbol | String key, ?untyped default) ?{ () -> untyped } -> untyped
    def key?: (Symbol | String key) -> bool
  end

  # Main Task class
  class Task
    self.@exported_methods: Array[Symbol]
    self.@dependencies_cache: Set[task_class]?
    self.@circular_dependency_checked: bool

    # Class methods
    def self.inherited: (Class subclass) -> void
    def self.exports: (*Symbol names) -> void
    def self.exported_methods: () -> Array[Symbol]
    def self.new: () -> Execution::TaskWrapper
    def self.cached_dependencies: () -> Set[task_class]
    def self.clear_dependency_cache: () -> void
    def self.run: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> untyped
    def self.clean: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> void
    def self.run_and_clean: (?args: Hash[Symbol, untyped], ?workers: Integer?) -> untyped
    def self.registry: () -> Execution::Registry
    def self.reset!: () -> void
    def self.tree: () -> String

    # Instance methods
    def run: () -> void
    def clean: () -> void
    def system: (*untyped args, **untyped opts) -> bool?
    def reset!: () -> void

    private

    # Private class methods
    def self.cached_wrapper: () -> Execution::TaskWrapper
    def self.define_instance_reader: (Symbol method_name) -> void
    def self.define_class_accessor: (Symbol method_name) -> void
    def self.validate_no_circular_dependencies!: () -> void
    def self.validate_workers!: (untyped workers) -> void
  end

  # Section class for abstraction layers (inherits from Task)
  class Section < Task
    def self.interfaces: (*Symbol interface_methods) -> void

    def run: () -> void
    def impl: () -> task_class

    private

    def apply_interface_to_implementation: (task_class implementation_class) -> void
  end

  # Execution module
  module Execution
    # TaskTiming struct (Data.define)
    class TaskTiming
      attr_reader start_time: Time
      attr_reader end_time: Time?

      # Data.define provides both positional and keyword argument constructors
      def initialize: (Time start_time, Time? end_time) -> void
                    | (start_time: Time, end_time: Time?) -> void

      def self.new: (Time start_time, Time? end_time) -> TaskTiming
                  | (start_time: Time, end_time: Time?) -> TaskTiming

      def self.start_now: () -> TaskTiming
      def duration_ms: () -> (Integer | Float)?
      def with_end_now: () -> TaskTiming
      def with: (?start_time: Time, ?end_time: Time?) -> TaskTiming
    end

    # Registry class for task instance management
    class Registry
      @tasks: Hash[Class, TaskWrapper]
      @threads: Array[Thread]
      @monitor: Monitor
      @abort_requested: bool

      def initialize: () -> void
      def get_or_create: (Class task_class) { () -> TaskWrapper } -> TaskWrapper
      def get_task: (Class task_class) -> TaskWrapper?
      def register: (Class task_class, TaskWrapper wrapper) -> void
      def register_thread: (Thread thread) -> void
      def wait_all: () -> void
      def reset!: () -> void
      def request_abort!: () -> void
      def abort_requested?: () -> bool
      def run: (Class task_class, Array[Symbol] exported_methods) -> untyped
      def failed_wrappers: () -> Array[TaskWrapper]
      def failed_clean_wrappers: () -> Array[TaskWrapper]
    end

    # ExecutionContext manages execution state and notifies observers about execution events
    class ExecutionContext
      THREAD_LOCAL_KEY: Symbol

      @monitor: Monitor
      @observers: Array[untyped]
      @execution_trigger: (^(Class, Registry) -> void)?
      @clean_trigger: (^(Class, Registry) -> void)?
      @output_capture: TaskOutputRouter?
      @original_stdout: IO?
      @runtime_dependencies: Hash[Class, Set[Class]]

      def self.current: () -> ExecutionContext?
      def self.current=: (ExecutionContext? context) -> void

      def initialize: () -> void
      def output_capture_active?: () -> bool
      def setup_output_capture: (IO output_io) -> void
      def teardown_output_capture: () -> void
      def output_capture: () -> TaskOutputRouter?
      def execution_trigger=: ((^(Class, Registry) -> void)? trigger) -> void
      def clean_trigger=: ((^(Class, Registry) -> void)? trigger) -> void
      def trigger_execution: (Class task_class, registry: Registry) -> void
      def trigger_clean: (Class task_class, registry: Registry) -> untyped
      def register_runtime_dependency: (Class from_class, Class to_class) -> void
      def runtime_dependencies: () -> Hash[Class, Set[Class]]
      def add_observer: (untyped observer) -> void
      def remove_observer: (untyped observer) -> void
      def observers: () -> Array[untyped]
      def notify_task_registered: (Class task_class) -> void
      def notify_task_started: (Class task_class) -> void
      def notify_task_completed: (Class task_class, ?duration: Float?, ?error: Exception?) -> void
      def notify_section_impl_selected: (Class section_class, Class impl_class) -> void
      def notify_set_root_task: (Class task_class) -> void
      def notify_set_output_capture: (TaskOutputRouter output_capture) -> void
      def notify_start: () -> void
      def notify_stop: () -> void
      def notify_clean_started: (Class task_class) -> void
      def notify_clean_completed: (Class task_class, ?duration: Float?, ?error: Exception?) -> void

      private

      def dispatch: (Symbol method_name, *untyped args, **untyped kwargs) -> void
    end

    # TaskOutputRouter for routing task output
    class TaskOutputRouter
      def initialize: (IO original_io) -> void
      def current_write_io: () -> IO?
      def start_capture: (Class task_class) -> void
      def stop_capture: () -> void
    end

    # Scheduler manages task dependency state and determines execution order
    class Scheduler
      STATE_PENDING: Symbol
      STATE_ENQUEUED: Symbol
      STATE_COMPLETED: Symbol
      CLEAN_STATE_PENDING: Symbol
      CLEAN_STATE_ENQUEUED: Symbol
      CLEAN_STATE_COMPLETED: Symbol

      @dependencies: Hash[Class, Set[Class]]
      @task_states: Hash[Class, Symbol]
      @completed_tasks: Set[Class]
      @reverse_dependencies: Hash[Class, Set[Class]]
      @clean_task_states: Hash[Class, Symbol]
      @clean_completed_tasks: Set[Class]

      def initialize: () -> void
      def build_dependency_graph: (Class root_task_class) -> void
      def next_ready_tasks: () -> Array[Class]
      def mark_enqueued: (Class task_class) -> void
      def mark_completed: (Class task_class) -> void
      def completed?: (Class task_class) -> bool
      def running_tasks?: () -> bool
      def merge_runtime_dependencies: (Hash[Class, Set[Class]] runtime_deps) -> void
      def build_reverse_dependency_graph: (Class root_task_class) -> void
      def next_ready_clean_tasks: () -> Array[Class]
      def mark_clean_enqueued: (Class task_class) -> void
      def mark_clean_completed: (Class task_class) -> void
      def clean_completed?: (Class task_class) -> bool
      def running_clean_tasks?: () -> bool

      private

      def ready_to_execute?: (Class task_class) -> bool
      def ready_to_clean?: (Class task_class) -> bool
    end

    # WorkerPool manages a pool of worker threads that execute tasks
    class WorkerPool
      attr_reader execution_queue: Thread::Queue

      @worker_count: Integer
      @registry: Registry
      @on_execute: ^(Class, TaskWrapper) -> void
      @execution_queue: Thread::Queue
      @workers: Array[Thread]

      def initialize: (registry: Registry, ?worker_count: Integer?) { (Class, TaskWrapper) -> void } -> void
      def start: () -> void
      def enqueue: (Class task_class, TaskWrapper wrapper) -> void
      def shutdown: () -> void
      def enqueue_shutdown_signals: () -> void

      private

      def default_worker_count: () -> Integer
      def worker_loop: () -> void
      def debug_log: (String message) -> void
    end

    # Executor class for parallel task execution (Producer-Consumer pattern)
    class Executor
      @registry: Registry
      @completion_queue: Thread::Queue
      @execution_context: ExecutionContext
      @scheduler: Scheduler
      @effective_worker_count: Integer?
      @worker_pool: WorkerPool
      @clean_worker_pool: WorkerPool?

      def self.execute: (Class root_task_class, registry: Registry, ?execution_context: ExecutionContext?) -> void
      def self.execute_clean: (Class root_task_class, registry: Registry, ?execution_context: ExecutionContext?) -> void
      def initialize: (registry: Registry, ?worker_count: Integer?, ?execution_context: ExecutionContext?) -> void
      def execute: (Class root_task_class) -> void
      def execute_clean: (Class root_task_class) -> void

      private

      def enqueue_ready_tasks: () -> void
      def enqueue_task: (Class task_class) -> void
      def get_or_create_wrapper: (Class task_class) -> TaskWrapper
      def execute_task: (Class task_class, TaskWrapper wrapper) -> void
      def run_main_loop: (Class root_task_class) -> void
      def handle_completion: (Hash[Symbol, untyped] event) -> void
      def enqueue_ready_clean_tasks: () -> void
      def enqueue_clean_task: (Class task_class) -> void
      def execute_clean_task: (Class task_class, TaskWrapper wrapper) -> void
      def run_clean_main_loop: (Class root_task_class) -> void
      def handle_clean_completion: (Hash[Symbol, untyped] event) -> void
      def all_tasks_cleaned?: () -> bool
      def setup_progress_display: (Class root_task_class) -> void
      def setup_output_capture_if_needed: () -> bool
      def teardown_output_capture: () -> void
      def start_progress_display: () -> void
      def stop_progress_display: () -> void
      def create_default_execution_context: () -> ExecutionContext
      def debug_log: (String message) -> void
      def raise_if_any_failures: () -> void
      def flatten_failures: (Array[TaskWrapper] failed_wrappers) -> Array[TaskFailure]
      def wrap_with_task_error: (Class task_class, Exception error) -> TaskError
      def raise_if_any_clean_failures: () -> void
      def flatten_clean_failures: (Array[TaskWrapper] failed_wrappers) -> Array[TaskFailure]
      def error_identity: (Exception error) -> Integer
    end

    # TaskWrapper class for task execution
    class TaskWrapper
      attr_reader task: Task
      attr_reader result: untyped
      attr_reader error: StandardError?
      attr_reader clean_error: StandardError?
      attr_reader timing: TaskTiming?

      @task: Task
      @registry: Registry
      @execution_context: ExecutionContext?
      @result: untyped
      @clean_result: untyped
      @error: StandardError?
      @clean_error: StandardError?
      @monitor: Monitor
      @condition: MonitorMixin::ConditionVariable
      @clean_condition: MonitorMixin::ConditionVariable
      @state: Symbol
      @clean_state: Symbol
      @timing: TaskTiming?

      STATE_PENDING: Symbol
      STATE_RUNNING: Symbol
      STATE_COMPLETED: Symbol
      STATE_FAILED: Symbol

      def initialize: (Task task, registry: Registry, ?execution_context: ExecutionContext?) -> void
      def state: () -> Symbol
      def pending?: () -> bool
      def completed?: () -> bool
      def failed?: () -> bool
      def clean_failed?: () -> bool
      def run: () -> untyped
      def clean: () -> untyped
      def run_and_clean: () -> untyped
      def get_exported_value: (Symbol method_name) -> untyped
      def mark_running: () -> bool
      def mark_completed: (untyped result) -> void
      def mark_failed: (StandardError error) -> void
      def mark_clean_running: () -> bool
      def mark_clean_completed: (untyped result) -> void
      def mark_clean_failed: (StandardError error) -> void
      def wait_for_completion: () -> void
      def wait_for_clean_completion: () -> void
      def method_missing: (Symbol name, *untyped args) ?{ (*untyped) -> untyped } -> untyped
      def respond_to_missing?: (Symbol name, ?bool include_private) -> bool

      private

      def trigger_execution_and_wait: () -> void
      def trigger_clean_and_wait: () -> void
      def execute_clean: () -> void
      def wait_for_clean_dependencies: () -> void
      def check_abort!: () -> void
      def update_progress: (Symbol state, ?duration: Numeric?, ?error: Exception?) -> void
      def debug_log: (String message) -> void
    end

    # TreeProgressDisplay class for tree-based progress visualization
    class TreeProgressDisplay
      SPINNER_FRAMES: Array[String]
      COLORS: Hash[Symbol, String]
      ICONS: Hash[Symbol, String]

      @output: IO
      @tasks: Hash[Class, TaskProgress]
      @monitor: Monitor
      @spinner_index: Integer
      @renderer_thread: Thread?
      @running: bool
      @nest_level: Integer
      @root_task_class: Class?
      @tree_structure: Hash[Symbol, untyped]?
      @section_impl_map: Hash[Class, Class]
      @last_line_count: Integer

      # Shared class methods
      def self.section_class?: (Class klass) -> bool
      def self.nested_class?: (Class child_class, Class parent_class) -> bool
      def self.render_static_tree: (Class root_task_class) -> String

      # Static tree renderer (internal class)
      class StaticTreeRenderer
        @task_index_map: Hash[Class, Integer]

        def render: (Class root_task_class) -> String

        private

        def build_tree: (Class task_class, String prefix, bool is_impl, Set[Class] ancestors) -> String
        def render_dependency_branch: (Class dep, String prefix, bool is_last, bool is_impl, Set[Class] ancestors) -> String
        def get_task_number: (Class task_class) -> String
        def colored_type_label: (Class klass) -> String
      end

      class TaskProgress
        attr_accessor state: Symbol
        attr_accessor start_time: Time?
        attr_accessor end_time: Time?
        attr_accessor error: Exception?
        attr_accessor duration: Numeric?
        attr_accessor is_impl_candidate: bool

        def initialize: () -> void
      end

      def initialize: (?output: IO) -> void
      def set_root_task: (Class root_task_class) -> void
      def register_section_impl: (Class section_class, Class impl_class) -> void
      def register_task: (Class task_class) -> void
      def task_registered?: (Class task_class) -> bool
      def update_task: (Class task_class, state: Symbol, ?duration: Numeric?, ?error: Exception?) -> void
      def task_state: (Class task_class) -> Symbol?
      def start: () -> void
      def stop: () -> void

      private

      def build_tree_structure: () -> void
      def build_tree_node: (Class task_class, Set[Class] ancestors) -> Hash[Symbol, untyped]?
      def register_tasks_from_tree: (Hash[Symbol, untyped] node) -> void
      def render_live: () -> void
      def render_final: () -> void
      def build_tree_display: () -> Array[String]
      def build_root_tree_lines: (Hash[Symbol, untyped] node, String prefix, Array[String] lines) -> void
      def render_children: (Hash[Symbol, untyped] node, String prefix, Array[String] lines, Class parent_task_class, bool ancestor_selected) -> void
      def format_tree_line: (Class task_class, TaskProgress? progress, bool is_impl, bool is_selected) -> String
      def format_unknown_task: (Class task_class, ?bool is_selected) -> String
      def spinner_char: () -> String
      def type_label_for: (Class task_class, ?bool is_selected) -> String
      def section_class?: (Class klass) -> bool
      def nested_class?: (Class child_class, Class parent_class) -> bool
    end
  end

  # StaticAnalysis module
  module StaticAnalysis
    # Analyzer class for dependency analysis
    class Analyzer
      def self.analyze: (Class task_class) -> Set[task_class]

      private

      def self.target_method_for: (Class task_class) -> Symbol
      def self.extract_method_location: (Class task_class, Symbol method_name) -> [String, Integer]?
    end

    # Visitor class for AST traversal
    class Visitor < Prism::Visitor
      @target_task_class: Class
      @target_method: Symbol
      @dependencies: Set[task_class]
      @in_target_method: bool
      @current_namespace_path: Array[String?]

      attr_reader dependencies: Set[task_class]

      def initialize: (Class task_class, Symbol target_method) -> void
      def visit_class_node: (Prism::ClassNode node) -> untyped
      def visit_module_node: (Prism::ModuleNode node) -> untyped
      def visit_def_node: (Prism::DefNode node) -> untyped
      def visit_call_node: (Prism::CallNode node) -> untyped

      private

      def within_namespace: (String? name) { () -> void } -> void
      def in_target_class?: () -> bool
      def in_impl_method?: () -> bool
      def extract_constant_name: (untyped node) -> String?
      def detect_task_dependency: (Prism::CallNode node) -> void
      def detect_impl_candidate: (untyped node) -> void
      def extract_receiver_constant: (untyped receiver) -> String?
      def resolve_and_add_dependency: (String constant_name) -> void
      def resolve_constant: (String name) -> task_class?
      def resolve_with_namespace_prefix: (String name) -> task_class?
      def valid_dependency?: (task_class klass) -> bool
      def is_parallel_task?: (task_class klass) -> boolish
      def is_parallel_section?: (task_class klass) -> boolish
    end

    # DependencyGraph class for topological sorting and cycle detection
    class DependencyGraph
      include TSort[Class]

      @graph: Hash[Class, Set[Class]]

      def initialize: () -> void
      def build_from: (Class root_task_class) -> self
      def sorted: () -> Array[Class]
      def cyclic?: () -> bool
      def strongly_connected_components: () -> Array[Array[Class]]
      def cyclic_components: () -> Array[Array[Class]]
      def all_tasks: () -> Array[Class]
      def dependencies_for: (Class task) -> Set[Class]

      # TSort interface methods (required by TSort module)
      def tsort_each_node: () { (Class) -> void } -> void
      def tsort_each_child: (Class node) { (Class) -> void } -> void

      private

      def collect_dependencies: (Class task_class) -> void
    end
  end
end
